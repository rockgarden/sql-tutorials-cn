# [在关系数据库中存储树结构](https://www.baeldung.com/sql/storing-tree-in-rdb)

1. 介绍

    在本文中，我们将探索在关系数据库中存储树结构的几种方法。例如，家谱或嵌套注释层次结构将适合这样的模型。

2. 问题是什么？

    [关系数据库](https://www.baeldung.com/cs/relational-database)在存储表格数据方面非常出色，其中一些数据与其他数据有关。我们可以非常容易地将数据存储在两个相互关联的不同表中。

    当关系指向同一表时，这是可能的，但它变得更加复杂。既要正确地再次读取数据，又要要写入数据并保持完整性。如果我们想要一个深度嵌套结构，而不仅仅是单一层次的关系，这就变得更加复杂了。

    如果我们想要读取嵌套树结构的单级，这与任何正常查询相同。然而，如果我们想读取整个结构，我们需要能够穿越树的许多层次。更糟糕的是，它可能是任意数量的级别，因此我们不能将此计划到我们的查询中。

    相反，如果我们想在树结构的底部写入一个新节点，那么这是一个简单的写入。然而，如果我们想写入树结构的中间，或者如果我们想在整个结构中进行更新，这很快就会变得非常复杂，并可能破坏记录的完整性。

3. JSON Blob

    实现这一目标的最简单方法是放弃关系数据库，并将结构存储在JSON blob中。这让我们忽略了许多记录中读写的复杂性，只是将所有内容存储为单个记录。然后，我们将在我们的应用程序代码中进行任何解析和更新，而不是在我们的数据库中。

    数据库引擎将自动为我们做许多我们无法从中受益的事情。然而，这样做往往损失多于收获。例如，我们失去了整个引用完整性的概念，无论是在树中的节点之间还是在其他表之间。由于整个树存储在单个记录中，因此不可能有数据库控制的外来键指向单个节点或从单个节点指向其他表。

    这也不是很大规模。如果我们将整个树存储为单个记录，那么在它变得难以操作而无法读取和写入之前，该记录可以有多大是有限制的。

4. 存储父键

    一旦我们决定要单独存储每个节点，而不是一次性存储整棵树，我们就需要决定实现这一目标的最佳方法。

    其中一种方法是在每个节点上存储其直系父节点的 ID。没有父节点的节点存储 NULL，而有父节点的节点可以存储父节点的引用。例如，我们可以将表创建为：

    ```java
    CREATE TABLE tree (
        node_id INT PRIMARY KEY,
        parent_id INT NULL REFERENCES tree (node_id),
        .... other columns ....
    );
    ```

    然后，这将允许我们存储以下树：

    ![商店树](/pic/store-tree.webp)

    如下：

    | node_id | parent_id | Other Columns |
    |---------|-----------|---------------|
    | 1       | NULL      | …             |
    | 2       | 1         | …             |
    | 3       | 1         | …             |
    | 4       | 3         | …             |
    | 5       | 3         | …             |

    这为我们提供了数据库中的引用完整性，因为我们可以确保parent_id列中的值也存在于node_id列中。

    我们还可以使用单个语句轻松地将记录插入正确的树中：

    `INSERT INTO tree (node_id, parent_id) VALUES (6, 5);`

    以及使用单个语句将树的一部分移动到不同的父节点：

    `UPDATE tree SET parent_id = 1 WHERE node_id = 4;`

    然而，在这里阅读整棵树更加复杂。如果没有额外的数据库支持——例如递归通用表表达式——我们将不得不单独选择树的每个级别，并将其放在应用程序中。同样，读取给定节点的整个祖先列表也需要一次一个地完成。

    显然，这将非常低效，那么我们如何改进这一点呢？

    1. 使用递归通用表表达式检索

        如果我们的数据库引擎支持递归通用表表达式，则可以使用WITH RECURSIVE子句一次性查询这样的结构。

        这样做涉及编写一个查询，该查询基本上将表重新连接到自身，并通知数据库引擎，它应该递归地这样做，直到行用完。

        例如，要查询上面的表格，我们可以做：

        ```sql
        WITH RECURSIVE rectree AS (
        SELECT *
            FROM tree
        WHERE node_id = 1
        UNION ALL
        SELECT t.*
            FROM tree t
            JOIN rectree
            ON t.parent_id = rectree.node_id
        ) SELECT * FROM rectree;
        ```

        这将从选择node_id = 1的节点开始，在树上递归，找到t.parent_id = rectree.node_id的行，直到没有返回更多行。如果我们需要列出所有祖先而不是所有子节点，可以编写类似的查询，以向相反的方向穿越。

        这是使用这种树结构的最有效方法，因为我们可以以相对便宜的价格将记录插入数据库，并查询整个树结构。然而，并非所有数据库引擎都支持这种形式的查询，因此对我们来说可能不是一个选项。例如，MySQL在8.0中支持这一点，但在早期版本中不支持。

    2. 给整棵树贴上标签

        另一种允许我们检索整棵树的方法是增加一列来标识每个节点所属的树。这可以是根节点的 ID，也可以是整个树的其他标识符。

        这意味着我们的表多了一列，因此我们要存储更多的数据。这也意味着向表中插入记录要稍微复杂一些，因为我们需要同时提供直系父节点和树的根节点。不过，这意味着我们现在只需一次查询就能选择同一棵树中的每个节点，而不再需要多次查询：

        `SELECT * FROM tree WHERE tree_id = 1;`

        这样，我们就能在内存中拼凑出这个查询所需的树结构。

        遗憾的是，我们不能用它来选择子树。我们也无法高效地列出某个节点的所有祖先。我们能做的最好的办法就是列出整个树，然后自己从返回的数据中找出祖先。

        不过，根据我们的具体要求，这可能不是问题。

5. 闭合表

    我们可以使用另一种机制将图形与节点分开存储在所谓的闭包表中。这个并行表将存储每个节点的每个祖先，包括节点与其祖先之间的距离。

    例如，上述树的闭包表将是：

    | node_id | parent_id | depth |
    |---------|-----------|-------|
    | 2       | 1         | 1     |
    | 3       | 1         | 1     |
    | 4       | 3         | 1     |
    | 4       | 1         | 2     |
    | 5       | 3         | 1     |
    | 5       | 1         | 2     |

    这使我们能够非常容易地搜索整个子树，并检索任何给定节点的整组祖先。

    然而，在树中插入和更新节点更加复杂。根据节点的深度，我们必须在闭包表中创建或更新许多记录。移动节点也非常昂贵，因为我们需要重新计算正在移动的子树中每个节点的闭包表。

6. 存储路径

    另一种选择是将整个路径存储在树中，而不仅仅是直接的父路径。在这种情况下，我们上面的树将存储为：

    | node_id | path | Other Columns |
    |---------|------|---------------|
    | 1       | NULL | …             |
    | 2       | 1    | …             |
    | 3       | 1    | …             |
    | 4       | 1.3. | …             |
    | 5       | 1.3. | …             |

    在这里，我们的路径列是一个字符串，由树中每个祖先的ID组成，由句号分隔。一些数据库引擎支持本机数组或类似的结构，可以代替使用。

    这样做对阅读我们表格中的数据有很多好处。每行都有其父级的整个层次结构。我们还可以使用LIKE运算符轻松查询子树：

    `SELECT * FROM tree WHERE path LIKE '1.3.%';`

    请注意，我们在末尾包含一个句号，这样我们就可以进行匹配，而不必担心节点的一部分匹配。例如，如果没有最后句，以下查询查询：

    `SELECT * FROM tree WHERE path LIKE '1.3%';`

    也会错误地匹配任何包含“1.30”等值的东西。

    将新记录插入树中也相对简单。我们需要知道节点的正确路径，该路径可以从父节点推导。然而，移动节点更加复杂。如果我们只移动一个叶子节点，这是唯一需要更新的路径。但是，如果我们要移动一个有子节点的节点，那么整个子树都需要更新，每个节点都需要以自己的方式更新。

    然而，通过这种方式，我们失去了树内的引用完整性。我们无法让数据库确保父节点都正确存在，因为它们只是结构化字符串的一部分。

    我们还需要看看这对我们的需求有多有效。字符串上的LIKE匹配效率低于整数键上的等式匹配，因此，如果我们不需要子树查找，这对有形利益的效率可能较低。

7. 摘要

    在这里，我们看到了几种技术，这些技术可用于在关系数据库中表示分层数据，以及每种技术的收益和成本。下次您需要存储此类数据时，使用专用图形数据库不是一个选项，为什么不试试这些选项之一呢。
